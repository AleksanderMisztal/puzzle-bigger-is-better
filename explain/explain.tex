% !TeX spellcheck = en_GB

\documentclass[runningheads,11pt,a4paper]{llncs}
\pagestyle{plain}
%\let\spvec\vec
\let\vec\accentvec

\newcommand\hmmax{0}
\newcommand\bmmax{0}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{<-> mathx10}{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareMathAccent{\widebar}{0}{mathx}{"73}

%\let\spvec\vec
\usepackage{amssymb,amsmath}
\let\vec\spvec
%\usepackage{newtxmath,newtxtext}
\usepackage{newtxtext}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[most]{tcolorbox}

\def\vec#1{\mathchoice{\mbox{\boldmath$\displaystyle#1$}}
  {\mbox{\boldmath$\textstyle#1$}} {\mbox{\boldmath$\scriptstyle#1$}}
  {\mbox{\boldmath$\scriptscriptstyle#1$}}}
\usepackage[a4paper,centering]{geometry}
\usepackage{soul}
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{hyperref} % [backref]

\include{macros}

\hypersetup{final}
\usepackage[advantage,asymptotics,adversary,sets,keys,ff,lambda,primitives,events,operators,probability,logic,mm,complexity,landau]{cryptocode}
\usepackage[normalem]{ulem}

\usepackage[capitalise]{cleveref}
\COMMENT{
\usepackage{refcheck}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% https://tex.stackexchange.com/questions/87610/making-refcheck-work-with-cleveref
%%% Macros to make cleveref and refcheck to work together:
\makeatletter
\newcommand{\refcheckize}[1]{%
	\expandafter\let\csname @@\string#1\endcsname#1%
	\expandafter\DeclareRobustCommand\csname relax\string#1\endcsname[1]{%
		\csname @@\string#1\endcsname{##1}\@for\@temp:=##1\do{\wrtusdrf{\@temp}\wrtusdrf{{\@temp}}}}%
	\expandafter\let\expandafter#1\csname relax\string#1\endcsname
}
\newcommand{\refcheckizetwo}[1]{%
	\expandafter\let\csname @@\string#1\endcsname#1%
	\expandafter\DeclareRobustCommand\csname relax\string#1\endcsname[2]{%
		\csname @@\string#1\endcsname{##1}{##2}\wrtusdrf{##1}\wrtusdrf{{##1}}\wrtusdrf{##2}\wrtusdrf{{##2}}}%
	\expandafter\let\expandafter#1\csname relax\string#1\endcsname
\makeatother
}

\refcheckize{\cref}
\refcheckize{\Cref}
\refcheckizetwo{\crefrange}
\refcheckizetwo{\Crefrange}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{datetime}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{paralist}	
\usepackage[mathscr]{euscript}
\usepackage{wrapfig}
\usepackage[color=green!20]{todonotes}
\usepackage{bbm}
\usepackage{boxedminipage}
\usepackage{multicol}
\usepackage{mdframed}
\usepackage{multirow}
%\usepackage{tabu}
\usepackage{dashbox}
\usepackage{adjustbox}
\usepackage[most]{tcolorbox}

%\usepackage{pgfplots}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,patterns,circuits.logic.US}

%\newcommand{\newdefsd}[1] {\setlength{\fboxsep}{0.9pt}\colorbox{gray!12}{\(\displaystyle #1\)}}
\newcommand{\newdefst}[1] {{\setlength{\fboxsep}{0.9pt}\colorbox{gray!12}{#1}}}

\definecolor{lightgreen}{rgb}{0.85,1,0.85}
\definecolor{lightyellow}{rgb}{1,1,0.85}
\definecolor{darkgreen}{rgb}{0,0.45,0}
\definecolor{darkred}{rgb}{0.6,0,0}
\definecolor{darkbrown}{rgb}{0.50, 0.36, 0.23}
\definecolor{darkmagenta}{rgb}{0.5,0,0.5}
\definecolor{darkblue}{rgb}{0,0,0.74}
\definecolor{lightred}{rgb}{1,0.9,0.9}
%\definecolor{brinkpink}{rgb}{0.55, 0.25, 0.3}
\definecolor{goodc}{rgb}{0.5,0.5,0.3}

\definecolor{macrocolor}{rgb}{0,0,0}

%FOR SUBMISSION
%\newcommand{\changedj}[1] {{\color{black}#1}}
%\newcommand{\changedh}[1] {{\color{black}#1}}
%\newcommand{\changedm}[1] {{\color{black}#1}}

\newtcbox{\dottedbox}[1][]{
	math upper,
	baseline=0.23\baselineskip,
	%	equal height group=dashedbox,
	nobeforeafter,
	colback=white,
	boxrule=0pt,
	enhanced jigsaw,
	boxsep=0pt,
	top=1pt,
	bottom=1pt,
	left=1pt,
	right=1pt,
	borderline horizontal={0.5pt}{0pt}{dotted},
	borderline vertical={0.5pt}{0pt}{dotted},
	%	drop lifted shadow,
	#1
}

\newtheorem{fact}{Fact}

\newcommand{\ccb} {\cellcolor{lightyellow}}
\newcommand{\ccc} {\cellcolor{lightred}}
\newcommand{\ccd} {\cellcolor{lightblue}}

\DeclareRobustCommand{\aleks}[2]  {{\color{darkred}\sethlcolor{lightgreen}\hl{\textsf{Aleks #1:} #2}}}

\DeclareRobustCommand{\michals}[2]  {{\color{darkgreen}\sethlcolor{lightyellow}\hl{\textsf{Michal #1:} #2}}}

\usepackage[T1]{fontenc}

\newcommand{\oursubsub}[1] {\subsubsection{#1}}
\newcommand{\ourpar}[1] {\paragraph{#1}}

% General mathematics

\newcommand{\SENDMSGRIGHT}[1]  {\sendmessageright{width=11cm,centercol=4,top=#1,style={black,thick}}}
\newcommand{\SENDMSGLEFT}[1]  {\sendmessageleft{width=11cm,centercol=4,top=#1,style={black,thick}}}

\newcommand{\mathpint}[1] {{\pgfmathparse{int(#1)}\pgfmathresult}}

\usepackage{booktabs}
\newcommand{\insubmitted}[1] {}
\newcommand{\infinal}[1] {#1}

\usepackage{comment}

%%%%%%%%%%%%%%%%%%%%%

\title{ZkHack. On the importance of denting the SRS}

\infinal{%
\author{Nethermind Research}
\institute{}
%\\ 	\email{firstname.lastname@gmail.com}}
}

\allowdisplaybreaks

\begin{document}
\sloppy
\maketitle

\subsubsection*{Notation.}
We use bracket notation to denote group elements. Namely, for an element $g_1^{a} \in \GRP_1$ we write $\gone{a}$. Similarly for elements of $\GRP_2, \GRP_T$. We use additive notation, that is we write $\gone{a} + \gone{b}$ to denote element $g_1^{a} \cdot g_1^{b}$. We use $\bullet$ to denote a bilinear pairing between elements $\gone{a}$ and $\gtwo{b}$,~i.e. we write $\gone{a} \bullet \gtwo{b} = \gtar{ab}$.

\newcommand{\ck}{\pcalgostyle{ck}}
\renewcommand{\com}{\pcalgostyle{Commit}}
\renewcommand{\open}{\pcalgostyle{Open}}
\renewcommand{\verify}{\pcalgostyle{Verify}}

\subsubsection*{High level overview of the algorithm.}
The commitment key of the (broken) argument equals $\ck = \smallset{\gone{1, \tau, \ldots, \tau^{2 dim - 1}},  \gtwo{1, \ldots, \tau^{dim}}}$. 
\begin{description}
    \item[$\com (\ck, \vec{v})$:] To commit to a vector $\vec{v} = (v_0, \ldots, v_{dim - 1})$ of length $dim$. We define polynomial $a(X) = v_0 X+ v_1 X^2 + \ldots + v_{dim - 1}$. The committer computes and outputs the KZG commitment to $a(X)$, i.e.~$a(\tau)$.
    %
    \item[$\open (\ck, \gone{a (tau)}, \vec{w})$:] We will denote by $\tilde{\vec{w}} = (\tilde{w}_0, \ldots, \tilde{w}_{dim - 1})$ a vector of length $dim$ such that $\tilde{w}_i = w_{dim - 1 - i}$, i.e.~$\tilde{\vec{w}}$ is $\vec{w}$ read from right to left. Given the public vector $\vec{w}$, the committer computes: 
    \begin{itemize}
        \item polynomial $b(X) = (0 || \tilde{\vec{w}})^\top \cdot (1, X, X^2, \ldots, X^{dim})$,
        \item polynomial $c (X) = a (X) \cdot b(X)$. We note that polynomial's $c (X)$ coefficient to $X^{dim + 1}$ equals $v_0 w_0 + \ldots + v_{dim - 1} w_{dim - 1}$, i.e.~the inner product of $\vec{v}$ and $\vec{w}$. We denote the inner product by $ip$. We define a polynomial $d(X) = c(X) - ip \cdot X^{dim + 1}$.
    \end{itemize}
    Eventually, the committer outputs the KZG commitment to $d(X)$, i.e.~$d(\tau)$.
    %
    \item[$\verify (\ck, \gone{a(\tau)}, \gone{d(\tau)}, ip, \vec{w})$:] $ip$ is the claimed inner product of vectors $\vec{v}$ and $\vec{w}$. The verifier computes $b (X) = (0 || \tilde{\vec{w}})^\top \cdot (1, X, X^2, \ldots, X^{dim})$ and accepts if $\gone{a (\tau)} \bullet \gtwo{b(\tau)} = ip \cdot \gone{\tau^{dim}} \bullet \gtwo{\tau} + \gone{d (\tau)} \bullet \gtwo{1}$.
\end{description}

\subsubsection*{Why it doesn't work?}
To build an intuition about the attack, we recall the following security assumption (which holds in the algebraic group model): If KZG polynomial commitment's key does not contain element $\gone{\tau^q}$, then no adversary $\adv$ can commit to a polynomial that has non-zero coefficient to $X^q$. More precisely, in the AGM, if $\adv$ outputs a commitment to a polynomial $f(X)$ that has a non-zero coefficient to $X^q$, then $\adv$ can be used to break a (variant of) discrete logarithm assumption and reveal the trapdoor $\tau$. 

We show that a malicious prover can convince the verifier on a false inner product value $ip'$. We note that polynomial $d(X)$, when computed correctly, has $0$ as a coefficient to $X^{dim + 1}$. This observation was used to ensure ILV's security (as presented in the Vampire paper). 

We observe that the verifier checks in the verification equation that $\gone{d(\tau)}$ has been computed correctly. Really, correctly computed $\gone{d (\tau)}$ is a commitment to a polynomial $a(X) \cdot b(X) - ip \cdot X^{dim + 1}$, that is $d(X)$.

In the proposed scheme, there is no gap in the SRS, what allows a malicious prover to coin an attack. A malicious prover follows the protocol, except it uses $ip'$ whenever an honest prover would use $ip$. More precisely, it computes $d(\tau) \gets c(\tau) - ip' \cdot \tau^{dim + 1}$. Since the verification equation checks $a(\tau) \cdot b (\tau) = ip' \cdot \tau^{dim + 1} + d(\tau)$, what is exactly the case, the verifier accepts the proof.
\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
